#!/usr/bin/env python
#
#   pymovetoimplicit.py
#
#   Continually (at 100Hz!) send commands to the robot, providing
#   implicit moves to goal locations - using a filter.
#
import sys
import rospy
import math
import cv2
import cv_bridge
import requests
import json
import numpy as np
import imutils

from sensor_msgs.msg import JointState, Image
from std_msgs.msg    import Float64
from threading import Lock


def get_corners_from_contours(contours, corner_amount=4):
    """
    Finds four corners from a list of points on the goal
    epsilon - the minimum side length of the polygon generated by the corners

    Parameters:
        :param: `contours` - a numpy array of points (opencv contour) of the
                             points to get corners from
        :param: `corner_amount` - the number of corners to find
    """
    coefficient = .05
    while True:
        # print(contours)
        epsilon = coefficient * cv2.arcLength(contours, True)
        # epsilon =
        # print("epsilon:", epsilon)
        poly_approx = cv2.approxPolyDP(contours, epsilon, True)
        hull = cv2.convexHull(poly_approx)
        if len(hull) == corner_amount:
            return hull
        else:
            if len(hull) > corner_amount:
                coefficient += .01
            else:
                coefficient -= .01 

def sort_corners(corners, center):
    """
    Sorts the corners in clockwise format around the center
    Parameters:
        :param: `corners` - a numpy array of coordinates of corners of the goal
        :param: `center` - a numpy array of size 2 with the center in it
    """
    top = []
    bot = []
    # print("center:", center)
    for i in range(len(corners)):
        # print("corners[i][0][1]:", corners[i][0][1])
        if(corners[i][0][1] < center[1]):
            top.append(corners[i])
        else:
            bot.append(corners[i])
    # print("top:", top)
    tl = top[1] if top[0][0][0] > top[1][0][0] else top[0]
    tr = top[0] if top[0][0][0] > top[1][0][0] else top[1]
    bl = bot[1] if bot[0][0][0] > bot[1][0][0] else bot[0]
    br = bot[0] if bot[0][0][0] > bot[1][0][0] else bot[1]
    return np.array([tl, tr, br, bl], np.int32)


#
#   image subscriber callback function for the usb_cam
def goalCallback(msg):
    print("recieved image from /usb_cam/image_raw")

def grabImage(filename):
    """
        Grabs exactly one image from a camera
        
        :param camera_name: The image of the camera that should be saved
        :type camera_name: str
        :param filename: The full path of the filename where this image should be saved
        :type filename: str 
    """
    msg=rospy.wait_for_message("usb_cam/image_raw", Image)
    print(msg.height, msg.width)       
    #print(msg)
    img = cv_bridge.CvBridge().imgmsg_to_cv2(msg, "bgr8")
    #print(img)
    img, corners = crop(img)
    
    #cv2.imshow(filename, crop(img))
    #cv2.waitKey()
    cv2.imwrite(filename, img)
    return corners
    #rospy.loginfo("Saved Image %s"%filename)

    
def crop(im):
    '''
    Takes image of board in,
    returns the same image cropped to only show only
    the board, as found by creatinga countour around
    the largest white rectangle.
    '''
    # print(im.shape)
    gim = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)# grayscale image\
    edged = cv2.Canny(gim, 30, 200)
    contours = cv2.findContours(edged.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    contours = imutils.grab_contours(contours)
    contours = sorted(contours, key = cv2.contourArea, reverse = True)[:10] # sorts to find 10 biggest contours
    outer_board = None # the contour representing the largest square contour
    cnt = None
    for c in contours:
        peri = cv2.arcLength(c, True)
        approx = cv2.approxPolyDP(c, .015 * peri, True)
        if(len(approx) == 4):
            outer_board = np.array(c)
            cnt = c
            break
    #Deal with corners
    hull = get_corners_from_contours(cnt)
    middle = np.mean(hull, axis = 0)[0,:]
    corners = sort_corners(hull, middle)
    
    x = outer_board[:,0][:,1]
    y = outer_board[:,0][:,0]
    xmin = np.min(x)
    xmax = np.max(x)
    ymin = np.min(y)
    ymax = np.max(y)
    off = 20
    
    focused_im = im[xmin-off:xmax+off, ymin-off:ymax+off]
    
    mask = np.ones(im.shape, np.bool)
    mask[xmin-off:xmax+off, ymin-off:ymax+off] = 0

    mean_col = np.mean(im[1,:])
    for i in range(mask.shape[0]):
        for j in range(mask.shape[1]):
            if mask[i,j,0] == 1:
                im[i,j] = mean_col
    
    return(im, corners)

def get_board_from_image(image):
    '''Returns detected board in fen representation given jpg image'''
    files = {'file': open(image,'rb')}
    post = requests.post("http://0.0.0.0:5000/upload", files = files)
    json_data = json.loads(post.text)
    result = json_data.get("fen", json_data)
    #print(result)
    return result

def get_board():
    path = "/home/user/hebi_ros_ws/images/"
    corners = grabImage(path + "board.jpg")
    result = get_board_from_image(path + "board.jpg")
    
    return (result, corners)
    
    

#
#   Main Code
#
if __name__ == "__main__":
    # Initialize the basic ROS node.
    #rospy.init_node('pyimage')


    while not rospy.is_shutdown():
        path = "/home/user/hebi_ros_ws/images/board.jpg"

        result, corners = get_board()
        print("corners: \n{}".format(corners))
        print(result)








